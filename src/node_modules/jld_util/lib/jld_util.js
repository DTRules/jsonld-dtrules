/*jslint node: true, vars: true */
'use strict';

//Copyright 2014 Resilient Network Systems, Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");  
//you may not use this file except in compliance with the License.  
//You may obtain a copy of the License at  
//
//     http://www.apache.org/licenses/LICENSE-2.0  
//
//Unless required by applicable law or agreed to in writing, software  
//distributed under the License is distributed on an "AS IS" BASIS,  
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
//See the License for the specific language governing permissions and  
//limitations under the License. 

//#JSON LD Access Utilities

var u = require('underscore');
var idVal = -1;

//**createV** - Create a value object; there are two forms:
//
//+ **createV(value)** - create a value object with only an @value property
//+ **createV(type, value)** - create a value object with an @type and @value property
function createV(p1, p2) {
    switch (arguments.length) {
    case 1:
        return {
            "@value": p1
        };
    case 2:
        return {
            "@type": p1,
            "@value": p2
        };
    }
    return;
} //createV

//**createN** - create a node with @id and @type properties; two forms are supported:
//
//+ **createN(type)** - generates a blank node unique with the process
//+ **createN(id, type)**
function createN(p1, p2) {
    switch (arguments.length) {
    case 1:
        idVal += 1;
        return {
            "@id": '_:jld_util' + idVal,
            "@type": [p1]
        };
    case 2:
        return {
            "@id": p1,
            "@type": [p2]
        };
    }
} //createN

//**createL** - create a list with the array value
function createL(array) {
    return {
        "@list": [array]
    };
} //createL

//**getV** - return the value of a value object or a singelton array; two forms are supported:
//
//+ **getV(valueObject)** - may also be a singelton array with a value or value object
//+ **getV(valueObjectArray)** - the value object array 
//is assumed to be a singelton array
//+ **getV(node, propertyName)** - the property value is 
//assumed to be a singelton array containing either a value or value object
function getV(p1, p2) {
    switch (arguments.length) {
    case 1:
        if (p1) {
            if (p1 !== undefined) {
                if (p1[0]["@value"]) {
                    return p1[0]["@value"];
                } else {
                    return p1[0];
                }
            } else if (p1["@value"]) {
                return p1["@value"];
            }
        }
        break;
    case 2:
        if (p1) {
            if (p1[p2]) {
                if (p1[p2][0] !== undefined) {
                    if (p1[p2][0]["@value"]) {
                        return p1[p2][0]["@value"];
                    } else {
                        return p1[p2][0];
                    }
                }
            }
        }
        break;
    }
} //getV

//**getA** - get the array value of a node's set or list property
function getA(node, propertyName) {
    var val = node[propertyName];
    if (node) {
        if (node[propertyName]) {
            if (node[propertyName]["@list"]) {
                return node[propertyName]["@list"];
            } else {
                return node[propertyName];
            }
        }
    }
} //getA

//**getN** - get the node value of a node property
//(expand turns all singelton node values into singelton arrays)
function getN(node, propertyName) {
    var val = node[propertyName];
    if (val) {
        if (val[0]) {
            return val[0];
        }
    }
} //getN

//**getI** - get the @id of a node
function getI(node) {
    if (node) {
        if (node["@id"]) {
            return node["@id"];
        }
    }
} //getI

//**setV** - set a value object value; three forms are supported:
//
//+ **setV(valueObject, value)** - may also set the value of a 
//singelton array of a value object or a value
//+ **setV(node, propertyName, value)** - where the node property is a 
//singelton array or value object and the value is a value object or 
//value; if the property is undefined, 
//it is created; if a value is input and a value object already exists, 
//its @value is set an its @type is retained; 
//+ **setV(node, propertyName, type, value)** - the type and value 
//are used to create a value object which is then set as though it were 
//input to the three parameter form 
function setV(p1, p2, p3, p4) {
    var vo;

    switch (arguments.length) {
    case 2:
        if (p1) {
            if (p1 !== undefined) {
                if (p1[0]["@value"]) {
                    p1[0]["@value"] = p2;
                } else {
                    p1[0] = p2;
                }
            } else {
                if (p1["@value"]) {
                    p1["@value"] = p2;
                }
            }
        }
        break;
    case 3:
        if (p1) {
            if (typeof p3 === 'object') {
                p1[p2] = [p3];
            } else {
                if (p1[p2]) {
                    if (p1[p2][0] !== undefined) {
                        if (p1[p2]["@value"]) {
                            p1[p2][0]["@value"] = p3;
                        } else {
                            p1[p2] = [p3];
                        }
                    } else {
                        p1[p2] = [p3];
                    }
                } else {
                    p1[p2] = [p3];
                }
            }
        }
        break;
    case 4:
        if (p3) {
            vo = {
                "@type": p3,
                "@value": p4
            };
            setV(p1, p2, vo);
        }
        break;
    }
} //setV

//**setN** - set a node property to a node; the node is wrapped in an array to 
//agree with the form of expanded singelton node values
function setN(node, propertyName, newNode) {
    node[propertyName] = [newNode];
} //setN

//**setL** - set a node list property to an array
function setL(node, propertyName, newArray) {
    if (node) {
        node[propertyName] = {
            "@list": newArray
        };
    }
} //setL

//**setS** - set a node set property to an array
function setS(node, propertyName, array) {
    if (node) {
        node[propertyName] = array;
    }
} //setS

//**addTo** - add the amount to the value; three forms are supported:
//
//+ **addTo(valueObject, amount)** - both value object and singelton 
//array of value object and value are supported
//* **addTo(node, propertyName, amount)** - the property can be a 
//singelton array of value or value object; if the property does not exist, 
//it is added with a singelton array containing the value
function addTo(p1, p2, p3) {
    switch (arguments.length) {
    case 2:
        if (typeof p2 === 'number') {
            if (p1) {
                if (p1 !== undefined) {
                    if (p1[0]["@value"]) {
                        if (typeof p1[0]["@value"] === 'number') {
                            p1[0]["@value"] += p2;
                        }
                    } else {
                        if (typeof p1[0] === 'number') {
                            p1[0] += p2;
                        }
                    }
                } else {
                    if (p1["@value"]) {
                        if (typeof p1["@value"] === 'number') {
                            p1["@value"] += p2;
                        }
                    }
                }
            }
        }
        break;
    case 3:
        if (typeof p3 === 'number') {
            if (p1) {
                if (p1[p2]) {
                    if (p1[p2][0] !== undefined) {
                        if (p1[p2][0]["@value"]) {
                            if (typeof p1[p2][0]["@value"] === 'number') {
                                p1[p2][0]["@value"] += p3;
                            }
                        } else {
                            if (typeof p1[p2][0] === 'number') {
                                p1[p2][0] += p3;
                            }
                        }

                    }
                } else {
                    p1[p2] = [p3];
                }
            }
        }
        break;
    }
} //addTo

//**subFrom** - subtract the amount from the value; three forms are supported:
//
//+ **subFrom(valueObject, amount)** - both value object and singelton 
//array of value object and value are supported
//* **subFrom(node, propertyName, amount)** - the property can be a 
//singelton array of value or value object; if the property does not exist, 
//it is added with a singelton array containing the negative of the value
function subFrom(p1, p2, p3) {
    switch (arguments.length) {
    case 2:
        if (typeof p2 === 'number') {
            if (p1) {
                if (p1 !== undefined) {
                    if (p1[0]["@value"]) {
                        if (typeof p1[0]["@value"] === 'number') {
                            p1[0]["@value"] -= p2;
                        }
                    } else {
                        if (typeof p1[0] === 'number') {
                            p1[0] -= p2;
                        }
                    }
                } else {
                    if (p1["@value"]) {
                        if (typeof p1["@value"] === 'number') {
                            p1["@value"] -= p2;
                        }
                    }
                }
            }
        }
        break;
    case 3:
        if (typeof p3 === 'number') {
            if (p1) {
                if (p1[p2]) {
                    if (p1[p2][0] !== undefined) {
                        if (p1[p2][0]["@value"]) {
                            if (typeof p1[p2][0]["@value"] === 'number') {
                                p1[p2][0]["@value"] -= p3;
                            }
                        } else {
                            if (typeof p1[p2][0] === 'number') {
                                p1[p2][0] -= p3;
                            }
                        }

                    }
                } else {
                    p1[p2] = [-p3];
                }
            }
        }
        break;
    }
} //subFrom

//**equalV** - return true if a value object's @value  matches the value; two forms are supported:
//
//+ **equalV(valueObject, value)** - both value object and singelton array of value object and value are supported
//+ **equalV(node, parameterName, value)**
//
function equalV(p1, p2, p3) {
    switch (arguments.length) {
    case 2:
        if (p1) {
            if (p1["@value"]) {
                return (p1["@value"] === p2);
            }
            if (p1 !== undefined) {
                if (p1[0]["@value"]) {
                    return (p1[0]["@value"] === p2);
                } else {
                    return (p1[0] === p2);
                }
            }
        }
        break;
    case 3:
        if (p1) {
            if (p1[p2]) {
                if (p1[p2][0] !== undefined) {
                    if (p1[p2][0]["@value"]) {
                        return (p1[p2][0]["@value"] === p3);
                    } else {
                        return (p1[p2][0] === p3);
                    }
                }
            }
        }
        break;
    }
} //equalV

//**equalN** true if both nodes have the same @id
function equalN(node1, node2) {
    if (node1 && node2) {
        if (node1["@id"] && node2["@id"]) {
            if ((typeof node1["@id"] === 'string') && (typeof node2["@id"] === 'string')) {
                return (node1["@id"] === node2["@id"]);
            }
        }
    }
} //equalN

//**push** - append a value or node to the end of a set or list; two forms are supported:
//
//+ **push(list, newNode)**
//+ **push(node, parameterName, newNode)** - if the property does not exist, 
//a list property initialized to the value is added
function push(p1, p2, p3) {
    switch (arguments.length) {
    case 2:
        if (p1) {
            if (p1["@list"] && Array.isArray(p1["@list"])) {
                p1["@list"].push(p2);
            } else if (Array.isArray(p1)) {
                p1.push(p2);
            }
        }
        break;
    case 3:
        if (p1) {
            if (p1[p2]) {
                if (p1[p2]["@list"] && Array.isArray(p1[p2]["@list"])) {
                    p1[p2]["@list"].push(p3);
                } else if (Array.isArray(p1[p2])) {
                    p1[p2].push(p3);
                }
            } else {
                p1[p2] = [p3];
            }
        }
        break;
    }
} //push

//**applyFunc** - apply a function to each element of an array; three forms are supported
//
//+ **applyFunc(array, Func)**
//+ **applyFunc(list, Func)**
//+ **applyFunc(node, propertyName, Func)** - for a set or list
function applyFunc(p1, p2, p3) {
    var i;
    switch (arguments.length) {
    case 2:
        if (typeof p2 === 'function') {
            if (p1) {
                if (p1["@list"]) {
                    if (Array.isArray(p1["@list"])) {
                        for (i = 0; i < p1["@list"].length; i += 1) {
                            p2(p1["@list"][i]);
                        }
                    }
                } else if (Array.isArray(p1)) {
                    for (i = 0; i < p1.length; i += 1) {
                        p2(p1[i]);
                    }
                }
            }
        }
        break;
    case 3:
        if (typeof p3 === 'function') {
            if (p1) {
                if (p1[p2]) {
                    if (p1[p2]["@list"]) {
                        if (Array.isArray(p1[p2]["@list"])) {
                            for (i = 0; i < p1[p2]["@list"].length; i += 1) {
                                p3(p1[p2]["@list"][i]);
                            }
                        }
                    } else if (Array.isArray(p1[p2])) {
                        for (i = 0; i < p1[p2].length; i += 1) {
                            p3(p1[p2][i]);
                        }
                    }
                }
            }
        }
        break;
    }
} //applyFunc

//**isIn** - returns true if the value is in the array; the array may also be an array of value objects
function isIn(array, value) {
    var found, i;
    if (array) {
        if (Array.isArray(array)) {
            if (array[0]["@value"]) {
                for (i = 0; i < array.length; i += 1) {
                    if (array[i]["@value"] === value) {
                        return true;
                    }
                }
            } else {
                return (u.indexOf(array, value) !== -1);
            }
        }
    }
} //isIn

//**isType** returns true if the type of the node or value matches the type specified; 
//three forms are supported:
//
//+ **isType(valueObject, type)** - type may be a single type or an array of types
//+ **isType(node, type)** - type may be a single type or an array of types
//+ **isType(node, propertyName, type)** - the property may be a singelton node array or 
//a singelton value object array; type may be a single type or an array of types
function isType(p1, p2, p3) {
    var types, testTypes;
    var i;
    switch (arguments.length) {
    case 2:
        if (typeof p2 === 'string') {
            testTypes = [p2];
        } else if (Array.isArray(p2)) {
            testTypes = p2;
        } else {
            return;
        }
        if (p1) {
            if (p1["@type"]) {
                if (typeof p1["@type"] === 'string') {
                    types = [p1["@type"]];
                } else if (Array.isArray(p1["@type"])) {
                    types = p1["@type"];
                }
            } else {
                return;
            }
        } else {
            return;
        }
        for (i = 0; i < testTypes.length; i += 1) {
            if (u.indexOf(types, testTypes[i]) !== -1) {
                return true;
            }
        }
        return false;
    case 3:
        if (typeof p3 === 'string') {
            testTypes = [p3];
        } else if (Array.isArray(p2)) {
            testTypes = p3;
        } else {
            return;
        }
        if (p1) {
            if (p1[p2]) {
                if (p1[p2][0] !== undefined) {
                    if (p1[p2][0]["@type"]) {
                        if (typeof p1[p2][0]["@type"] === 'string') {
                            types = [p1[p2][0]["@type"]];
                        } else if (Array.isArray(p1[p2][0]["@type"])) {
                            types = p1[p2][0]["@type"];
                        }
                    } else {
                        return;
                    }
                } else {
                    return;
                }
            } else {
                return;
            }
        } else {
            return;
        }
        for (i = 0; i < testTypes.length; i += 1) {
            if (u.indexOf(types, testTypes[i]) !== -1) {
                return true;
            }
        }
        return false;
    }
} //isType

module.exports = {
    createV: createV,
    createN: createN,
    createL: createL,
    getV: getV,
    getA: getA,
    getN: getN,
    getI: getI,
    setV: setV,
    setN: setN,
    setL: setL,
    setS: setS,
    addTo: addTo,
    subFrom: subFrom,
    equalV: equalV,
    equalN: equalN,
    push: push,
    applyFunc: applyFunc,
    isIn: isIn,
    isType: isType
};