/*jslint node: true, vars: true */
'use strict';

//Copyright 2014 Resilient Network Systems, Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");  
//you may not use this file except in compliance with the License.  
//You may obtain a copy of the License at  
//
//     http://www.apache.org/licenses/LICENSE-2.0  
//
//Unless required by applicable law or agreed to in writing, software  
//distributed under the License is distributed on an "AS IS" BASIS,  
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
//See the License for the specific language governing permissions and  
//limitations under the License. 

//#Decision Table Compiler
//
//
//#Code

var util = require('util');
var u = require('underscore');
var dt_t = require('./dt_common').dt_t;
var dt_p = require('./dt_common').dt_p;

//**compile** - returns an anonymous function that implements the DT; 
//this function takes the parameters as specified by the DT
//
//+ **dt** - a decision table in the form of an expanded JSON LD graph; it may contain inner decision tables
//+ **returns** - DT function if sucessful; otherwise an error msg

function compile(dt) {
    var dtModuleRequireSrc = 'var dt_t = require(\'dt\').dt_t; var dt_p = require(\'dt\').dt_p;';
    var dtSubtypeCnt;
    var innerDtFuncObjs = [];
    var innerDtVarSrc = '';
    var mainDtFuncObj;
    var mainDTFuncBodySrc;
    var mainDtEvalSrc;
    var mainDtFunc;
    var err;
    var i;

    //**validateParameters** - validate the dt's structure and types; the dt's JS expressions and statements are not validated
    //
    //+ **dt** - the dt to validate
    //+ **returns** - undefined if successful; otherwise an error msg
    function validateDt(dt) {
        var err;
        var otherwise;

        function validateParameters() {
            var parameters;
            var i;

            if (dt[dt_p.parameters]) {
                if (!dt[dt_p.parameters]['@list']) {
                    return 'dt_p:parameters must be a list';
                }
                parameters = dt[dt_p.parameters]['@list'];
                for (i = 0; i < parameters.length; i += 1) {
                    if (!(parameters[i]['@type'] && parameters[i]['@value'])) {
                        return 'malformed dt_p:parameters element';
                    }
                    if (typeof parameters[i]['@value'] !== 'string') {
                        return 'parameter name must be a string';
                    }
                }
            }

        } //validateParameters

        function validateVariables() {
            var variables;
            var i;

            if (dt[dt_p.variables]) {
                if (!dt[dt_p.variables]['@list']) {
                    return 'dt_p:variables must be a list';
                }
                variables = dt[dt_p.variables]['@list'];
                for (i = 0; i < variables.length; i += 1) {
                    if (typeof variables[i] !== 'string') {
                        return 'a variable must a string';
                    }
                }
            }

        } //validateVariables

        function validateInitialActions() {
            var initialActions;
            var i;

            if (dt[dt_p.initial_actions]) {
                if (!dt[dt_p.initial_actions]['@list']) {
                    return 'dt_p:variables must be a list';
                }
                initialActions = dt[dt_p.initial_actions]['@list'];
                for (i = 0; i < initialActions.length; i += 1) {
                    if (typeof initialActions[i] !== 'string') {
                        return 'an initial_action must a string';
                    }
                }
            }

        } //validateInitialActions

        function validateForLoops() {
            var forLoops;
            var i;

            if (dt[dt_p.for_loops]) {
                if (!dt[dt_p.for_loops]['@list']) {
                    return 'dt_p:for_loops must be a list';
                }
                forLoops = dt[dt_p.for_loops]['@list'];
                for (i = 0; i < forLoops.length; i += 1) {
                    if (u.indexOf(forLoops[i]['@type'], dt_t.for_loop) === -1) {
                        return 'dt_p:for_loops must only contain dt_t:for_loop elements';
                    }
                    if (!(forLoops[i][dt_p.for_element] && forLoops[i][dt_p.for_array])) {
                        return 'a dt_t:for_loop must has a dt_p:for_element and a dt_p:for_array';
                    }
                    if (!(forLoops[i][dt_p.for_element][0] && typeof forLoops[i][dt_p.for_element][0] === 'string')) {
                        return 'a for loop element must a string';
                    }
                    if (!(forLoops[i][dt_p.for_array][0] && typeof forLoops[i][dt_p.for_array][0] === 'string')) {
                        return 'a for loop array must a string';
                    }
                    if (forLoops[i][dt_p.for_while]) {
                        if (!(forLoops[i][dt_p.for_while][0] && typeof forLoops[i][dt_p.for_while][0] === 'string')) {
                            return 'a for loop array must a string';
                        }
                    }
                }
            }

        } //validateForLoops

        function validateForLoopInitialActions() {
            var forLoopInitialActions;
            var i;

            if (dt[dt_p.initial_actions]) {
                if (!dt[dt_p.initial_actions]['@list']) {
                    return 'dt_p:for_loop_initial_actions must be a list';
                }
                forLoopInitialActions = dt[dt_p.initial_actions]['@list'];
                for (i = 0; i < forLoopInitialActions.length; i += 1) {
                    if (typeof forLoopInitialActions[i] !== 'string') {
                        return 'a for loop initial action must a string';
                    }
                }
            }

        } //validateForLoopInitialActions

        function validateConditions() {

            var conditions;
            var i;

            if (!dt[dt_p.conditions]) {
                return 'a dt must have at least one condition';
            }
            if (!dt[dt_p.conditions]['@list']) {
                return 'dt_p:conditions must be a list';
            }
            conditions = dt[dt_p.conditions]['@list'];
            if (conditions.length === 0) {
                return 'a dt must have at least one condition';
            }
            for (i = 0; i < conditions.length; i += 1) {
                if (typeof conditions[i] !== 'string') {
                    return 'a condition must a string';
                }
                if ((i < (conditions.length - 1)) && (conditions[i] === 'otherwise')) {
                    return 'only the last condition is allowed to be an otherwise condition';
                }
            }
            if (conditions[conditions.length - 1] === 'otherwise') {
                otherwise = true;
            }

        } //validateConditions

        function validateActions() {

            var actions;
            var i;

            if (!dt[dt_p.actions]) {
                return 'a dt must have at least one action';
            }
            if (!dt[dt_p.actions]['@list']) {
                return 'dt_p:actions must be a list';
            }
            actions = dt[dt_p.actions]['@list'];
            if (actions.length < 1) {
                return 'a dt must have at least one action';
            }
            for (i = 0; i < actions.length; i += 1) {
                if (typeof actions[i] !== 'string') {
                    return 'an action must a string';
                }
            }

        } //validateActions

        function validatePolicies() {

            var policies;
            var i;

            function validatePolicy() {

                function validateConditionPattern(policyIndex, policiesLen, conditionPattern) {
                    var j;

                    if (!conditionPattern) {
                        return 'a dt_t:policy must have a dt_t:condition_pattern';
                    }
                    if (typeof conditionPattern[0] !== 'string') {
                        return 'a condition_pattern must a string';
                    }
                    for (j = 0; j < conditionPattern[0].length; j += 1) {
                        switch (conditionPattern[0][j]) {
                        case 'Y':
                            break;
                        case 'N':
                            break;
                        case ' ':
                            break;
                        case '*':
                            if (!(otherwise && (policyIndex === (policiesLen - 1)) && (j === (conditionPattern[0].length - 1)))) {
                                return 'only an otherwise condition can have an otherwise condition_pattern';
                            }
                            break;
                        default:
                            return 'a condition_pattern cannot contain a \'' + conditionPattern[0][j] + '\' character';
                        }
                    }

                } //validateConditionPattern

                function validateActionSelector(actionSelector) {
                    var j;

                    if (!actionSelector) {
                        return 'a dt_t:policy must have a dt_t:action_selector';
                    }
                    if (typeof actionSelector[0] !== 'string') {
                        return 'an action_selector must a string';
                    }
                    for (j = 0; j < actionSelector[0].length; j += 1) {
                        switch (actionSelector[0][j]) {
                        case 'X':
                            break;
                        case ' ':
                            break;
                        default:
                            return 'an action_selector cannot contain a \'' + actionSelector[0][j] + '\' character';
                        }
                    }
                } //validateActionSelector

                if (!dt[dt_p.policies]) {
                    return 'a dt must have at least one policy';
                }
                if (!dt[dt_p.policies]['@list']) {
                    return 'dt_p:policies must be a list';
                }
                if (!Array.isArray(dt[dt_p.policies]['@list'])) {
                    return 'dt_p:policies list must be an array';
                }
                policies = dt[dt_p.policies]['@list'];
                if (policies.length === 0) {
                    return 'a dt must have at least one policy';
                }
                if (((u.indexOf(dt['@type'], dt_t.balanced_dt)) !== -1) && (policies.length < 2)) {
                    return 'a balanced dt must have at least two policies';
                }
                for (i = 0; i < policies.length; i += 1) {
                    if (u.indexOf(policies[i]['@type'], dt_t.policy) === -1) {
                        return 'dt_p:policies must be of type dt_t:policy';
                    }
                    err = validateConditionPattern(i, policies.len, policies[i][dt_p.condition_pattern][0]);
                    if (err) {
                        return err;
                    }
                    err = validateActionSelector(policies[i][dt_p.action_selector][0]);
                    if (err) {
                        return err;
                    }
                }

            } //policy

        } //validatePolicies

        if (u.indexOf(dt['@type'], dt_t.dt) === -1) {
            return 'a dt must be a dt_t:dt';
        }

        if (u.indexOf(dt['@type'], dt_t.balaned_dt) !== -1) {
            dtSubtypeCnt += 1;
        }
        if (u.indexOf(dt['@type'], dt_t.first_dt) !== -1) {
            dtSubtypeCnt += 1;
        }
        if (u.indexOf(dt['@type'], dt_t.all_dt) !== -1) {
            dtSubtypeCnt += 1;
        }
        switch (dtSubtypeCnt) {
        case 0:
            return 'a dt must be either a dt_t:balaned_dt or a dt_t.first_dt or a dt_t.all_dt';
        case 2:
            return 'a dt must be either a dt_t:balaned_dt or a dt_t.first_dt or a dt_t.all_dt';
        case 3:
            return 'a dt must be either a dt_t:balaned_dt or a dt_t.first_dt or a dt_t.all_dt';
        }

        if (!dt[dt_p.dt_name]) {
            return 'a dt must have a dt_p:name';
        }

        err = validateParameters();
        if (err) {
            return err;
        }

        err = validateVariables();
        if (err) {
            return err;
        }

        err = validateInitialActions();
        if (err) {
            return err;
        }

        err = validateForLoops();
        if (err) {
            return err;
        }

        err = validateForLoopInitialActions();
        if (err) {
            return err;
        }

        err = validateConditions();
        if (err) {
            return err;
        }

        err = validateActions();
        if (err) {
            return err;
        }

        err = validatePolicies();
        if (err) {
            return err;
        }

    } //validateDt

    //**genDtSrc** - generates the function body source for a dt; 
    //note that all variables and function names in the context of 
    //the names declared by a dt must be prefixed with **dt_** to 
    //insure they do not conflict
    //
    //+ **dt** - the dt to generate
    //+ **returns** - dtFuncObj object with following properties 
    //+ *name* - null or inner dt name
    //+ *parameterNames* - array of parameter names
    //+ *funcBodySrc* - the dt function body source; this does not include some global state for the DT main function

    function genDtSrc(dt) {
        var dtFuncObj = {
            name: null,
            parameterNames: null,
            funcBodySrc: null
        };
        var funcStaticVarSrc = 'var dt_otherwise; var dt_matchedPolicies = []; var dt_conditionFunctionsLen; var dt_conditionResults = []; var dt_actionSelector; var dt_actionFunctionsEnabled = []; var dt_balancedDt, dt_firstDt, dt_allDt; var dt_ptype_found; var dt_i, dt_j; function dt_matchPolicy(policyIndex) {var j; for (j = 0; j < dt_policiesConditionPatterns[policyIndex].length; j += 1) {switch (dt_policiesConditionPatterns[policyIndex][j]) {case \'Y\': if (!dt_conditionResults[j]) {return false;} break; case \'N\': if (dt_conditionResults[j]) {return false;} break; case \' \':break; case \'*\': return false; break; default: return false; break;}} return true;}if (arguments.length !== dt_parameterTypes.length) {return \'error: the DT expects \' + dt_parameterTypes.length + \' parameters but has been given \' + arguments.length + \' parameters\';}for (dt_i = 0; dt_i < arguments.length; dt_i += 1) {if (arguments[dt_i][\'@type\']) {if (Array.isArray(arguments[dt_i][\'@type\'])) {dt_ptype_found = false; for (dt_j = 0; dt_j < arguments[dt_i][\'@type\'].length; dt_j += 1) {if (arguments[dt_i][\'@type\'][dt_j] === dt_parameterTypes[dt_i]) {dt_ptype_found = true;}} if (!dt_ptype_found) {return \'error: parameter \' + dt_i + \' is not of type \' + dt_parameterTypes[dt_i];}} else {if (arguments[dt_i][\'@type\'] !== dt_parameterTypes[dt_i]) {return \'error: parameter \' + dt_i + \' is not of type \' + dt_parameterTypes[dt_i];}}} else {if (dt_t.json !== dt_parameterTypes[dt_i]) {return \'error: parameter \' + dt_i + \' is not of type \' + dt_parameterTypes[dt_i];}}} for (dt_i = 0; dt_i < dt_Types.length; dt_i += 1) {switch (dt_Types[dt_i]) {case dt_t.balanced_dt: dt_balancedDt = true; break; case dt_t.first_dt: dt_firstDt = true; break; case dt_t.all_dt: dt_allDt = true; break;}} for (dt_i = 0; dt_i < dt_initialActionFunctions.length; dt_i += 1) {dt_initialActionFunctions[dt_i]();}';
        var funcStaticSrc = 'if (dt_conditionFunctions[dt_conditionFunctions.length - 1] === \'otherwise\') {dt_otherwise = true;dt_conditionFunctionsLen = dt_conditionFunctions.length - 1;} else {dt_conditionFunctionsLen = dt_conditionFunctions.length;} for (dt_i = 0; dt_i < dt_conditionFunctionsLen; dt_i += 1) {dt_conditionResults[dt_i] = dt_conditionFunctions[dt_i]();} dt_matchedPolicies = []; dt_match: for (dt_i = 0; dt_i < dt_policiesConditionPatterns.length; dt_i += 1) {if (dt_matchPolicy(dt_i)) {dt_matchedPolicies.push(dt_i); if (dt_firstDt) {break dt_match;}if (dt_balancedDt && (dt_matchedPolicies.length > 1)) {return \'a balanced decision table must only match a single policy; this matched policy \' + (dt_matchedPolicies[0] + 1) + \' and \' + (dt_matchedPolicies[1] + 1);}}} if ((dt_matchedPolicies.length === 0) && (dt_otherwise)) {dt_matchedPolicies.push(dt_policiesConditionPatterns.length - 1);} for (dt_i = 0; dt_i < dt_actionFunctions.length; dt_i += 1) {dt_actionFunctionsEnabled[dt_i] = false;} for (dt_i = 0; dt_i < dt_matchedPolicies.length; dt_i += 1) {dt_actionSelector = dt_policiesActionSelectors[dt_matchedPolicies[dt_i]]; for (dt_j = 0; dt_j < dt_actionSelector.length; dt_j += 1) {if (dt_actionSelector[dt_j] === \'X\') {dt_actionFunctionsEnabled[dt_j] = true;}}} for (dt_i = 0; dt_i < dt_actionFunctions.length; dt_i += 1) {if (dt_actionFunctionsEnabled[dt_i]) {dt_actionFunctions[dt_i]();}}';

        function typeSrc() {
            var types = 'var dt_Types = [';
            var i;

            for (i = 0; i < dt['@type'].length; i += 1) {
                types += '\'' + dt['@type'][i] + '\'';
                if (i !== dt['@type'].length - 1) {
                    types += ',';
                }
            }
            return (types += '];');

        } //typeSrc

        function parameterNames() {
            var parameters;
            var names = [];
            var i;

            if (dt[dt_p.parameters]) {
                parameters = dt[dt_p.parameters]['@list'];
                for (i = 0; i < parameters.length; i += 1) {
                    names[i] = parameters[i]['@value'];
                }
            }
            return names;

        } //parameterNames

        function parameterTypeSrc() {
            var parameters;
            var typeSrc = 'var dt_parameterTypes = [';
            var i;

            if (dt[dt_p.parameters]) {
                parameters = dt[dt_p.parameters]['@list'];
                for (i = 0; i < parameters.length; i += 1) {
                    typeSrc += '\'' + parameters[i]['@type'] + '\'';
                    if (i < parameters.length - 1) {
                        typeSrc += ',';
                    }
                }
            }
            return typeSrc + '];';

        } //parameterTypeSrc

        function variablesSrc() {
            var variables;
            var variableDecls = '';
            var i;

            if (dt[dt_p.variables]) {
                variables = dt[dt_p.variables]['@list'];
                for (i = 0; i < variables.length; i += 1) {
                    variableDecls += 'var ' + variables[i] + ';';
                }
            }
            return variableDecls;

        } //variablesSrc

        function initialActionsSrc() {
            var initialActions;
            var initialActionsDecl = 'var dt_initialActionFunctions = [';
            var i;

            if (dt[dt_p.initial_actions]) {
                initialActions = dt[dt_p.initial_actions]['@list'];
                for (i = 0; i < initialActions.length; i += 1) {
                    initialActionsDecl += 'function () {' + initialActions[i] + ';}';
                    if (i !== initialActions.length - 1) {
                        initialActionsDecl += ',';
                    }
                }
            }
            return initialActionsDecl + '];';

        } //initialActionsSrc

        function conditionsSrc() {
            var conditions;
            var conditionsDecl = 'var dt_conditionFunctions = [';
            var i;

            conditions = dt[dt_p.conditions]['@list'];
            for (i = 0; i < conditions.length; i += 1) {
                if (i !== conditions.length - 1) {
                    conditionsDecl += 'function () {return (' + conditions[i] + ');}';
                    conditionsDecl += ',';
                } else {
                    if (conditions[i] === 'otherwise') {
                        conditionsDecl += '\'otherwise\'';
                    } else {
                        conditionsDecl += 'function () {return (' + conditions[i] + ');}';
                    }
                }
            }
            return conditionsDecl + '];';

        } //conditionsSrc

        function actionsSrc() {
            var actions;
            var actionsDecl = 'var dt_actionFunctions = [';
            var i;

            actions = dt[dt_p.actions]['@list'];
            for (i = 0; i < actions.length; i += 1) {
                actionsDecl += 'function () {' + actions[i] + ';}';
                if (i !== actions.length - 1) {
                    actionsDecl += ',';
                }
            }
            return actionsDecl + '];';

        } //actionsSrc

        function policiesSrc() {
            var policies;
            var conditionPatternsDecl = 'var dt_policiesConditionPatterns = [';
            var actionSelectorsDecl = 'var dt_policiesActionSelectors = [';
            var i;

            policies = dt[dt_p.policies]['@list'];
            for (i = 0; i < policies.length; i += 1) {
                conditionPatternsDecl += '\'' + policies[i][dt_p.condition_pattern][0] + '\'';
                actionSelectorsDecl += '\'' + policies[i][dt_p.action_selector][0] + '\'';
                if (i !== policies.length - 1) {
                    conditionPatternsDecl += ',';
                    actionSelectorsDecl += ',';
                }
            }
            conditionPatternsDecl += '];';
            actionSelectorsDecl += '];';
            return conditionPatternsDecl + actionSelectorsDecl;

        } //policiesSrc

        //**forLoopsSrc** - the for loop initial actions and DT logic is placed in the inner loop of the for loops
        function forLoopsSrc() {
            var forLoops;
            var forLoopInitialActions;
            var src = '';
            var forLoop;
            var forLoopSrc;
            var forLoopElementSrc;
            var forLoopInitialActionSrc;
            var forLoopEndSrc = '';
            var forWhereSrc = '';
            var forWhereEndSrc = '';
            var element;
            var array;
            var indexVarBase = 'dt_index';
            var indexVar;
            var indexVarSrc = "";
            var i;

            if (!dt[dt_p.for_loops]) {
                return funcStaticVarSrc + funcStaticSrc;
            }
            forLoops = dt[dt_p.for_loops]['@list'];
            for (i = 0; i < forLoops.length; i += 1) {
                element = forLoops[i][dt_p.for_element][0];
                array = forLoops[i][dt_p.for_array][0];
                if (forLoops[i][dt_p.for_where]) {
                    forWhereSrc = 'if (' + forLoops[i][dt_p.for_where][0] + ') {';
                    forWhereEndSrc += '}';
                } else {
                    forWhereSrc = '';
                }
                indexVar = indexVarBase + i;
                if (i < forLoops.length - 1) {
                    indexVarSrc += indexVar + ',';
                } else {
                    indexVarSrc = 'var ' + indexVarSrc + indexVar + ';';
                }
                forLoopSrc = 'if (' + array + ') {for (' + indexVar + '=0;' + indexVar + '<' + array + '.length;' + indexVar + '+=1){';
                forLoopElementSrc = element + '=' + array + '[' + indexVar + '];';
                forLoopEndSrc += '}}';
                src += forLoopSrc + forLoopElementSrc + forWhereSrc;
            }

            if (dt[dt_p.for_loop_initial_actions]) {
                forLoopInitialActions = dt[dt_p.for_loop_initial_actions]['@list'];
                for (i = 0; i < forLoopInitialActions.length; i += 1) {
                    src += forLoopInitialActions[i] + ';';
                }
            }

            return (indexVarSrc + funcStaticVarSrc + src + funcStaticSrc + forWhereEndSrc + forLoopEndSrc);

        } //forLoopsSrc


        //If the dt is an inner dt, capture its name; else it is an anonymous main dt
        if (dt[dt_p.dt_name][0]['@type'] === dt_t.inner_dt_name) {
            dtFuncObj.name = dt[dt_p.dt_name][0]['@value'];
        }

        //Extract the dt parameter name list
        dtFuncObj.parameterNames = parameterNames();

        //Compose the src for the executor function
        dtFuncObj.funcBodySrc = variablesSrc() + typeSrc() + parameterTypeSrc() + initialActionsSrc() + conditionsSrc() + actionsSrc() + policiesSrc() + forLoopsSrc();
        return dtFuncObj;
    } //genDtSrc

    function parametersSrc(parameterNames) {
        var parameterSrc = '';
        var i;

        for (i = 0; i < parameterNames.length; i += 1) {
            parameterSrc += parameterNames[i];
            if (i !== parameterNames.length - 1) {
                parameterSrc += ',';
            }
        }
        return parameterSrc;

    } //parametersSrc

    //If there are inner DTs, validate them; generate their source and add them 
    //to the inner dts object using their name as their property
    if (dt[dt_p.inner_dts]) {
        for (i = 0; i < dt[dt_p.inner_dts].length; i += 1) {
            err = validateDt(dt[dt_p.inner_dts][i]);
            if (err) {
                return err;
            }
            innerDtFuncObjs.push(genDtSrc(dt[dt_p.inner_dts][i]));
        }
    }

    //Generate the variable source that contain the inner dt functions
    for (i = 0; i < innerDtFuncObjs.length; i += 1) {
        if (!innerDtFuncObjs[i].name) {
            return 'an inner dt must have a name';
        }
        innerDtVarSrc += 'var ' + innerDtFuncObjs[i].name + ' = function(' + parametersSrc(innerDtFuncObjs[i].parameterNames) + ') {' + innerDtFuncObjs[i].funcBodySrc + '};';
    }

    //Validate the main dt
    err = validateDt(dt);
    if (err) {
        return err;
    }

    //Generate and compile the main dt
    mainDtFuncObj = genDtSrc(dt);
    mainDTFuncBodySrc = '{' + dtModuleRequireSrc + innerDtVarSrc + mainDtFuncObj.funcBodySrc + '}';
    mainDtEvalSrc = 'mainDtFunc = function(' + parametersSrc(mainDtFuncObj.parameterNames) + ')' + mainDTFuncBodySrc;
    //console.log('\nmainDtEvalSrc: %j', mainDtEvalSrc);
    try {
        eval(mainDtEvalSrc);
    } catch (compileEx) {
        return util.inspect(compileEx, {
            depth: null
        });
    }
    return mainDtFunc;

} //compile

module.exports = {
    compile: compile
};
